# 加密工具函数

<cite>
**本文档引用的文件**
- [cryptoUtils.ts](file://src/utils/cryptoUtils.ts)
- [AESCrypto.vue](file://src/views/crypto/AESCrypto.vue)
- [RSACrypto.vue](file://src/views/crypto/RSACrypto.vue)
- [MD5Tool.vue](file://src/views/crypto/MD5Tool.vue)
- [SHAHasher.vue](file://src/views/crypto/SHAHasher.vue)
- [tool.ts](file://src/stores/tool.ts)
</cite>

## 目录
1. [AES加密算法实现](#aes加密算法实现)
2. [RSA非对称加密实现](#rsa非对称加密实现)
3. [哈希算法实现](#哈希算法实现)
4. [业务组件调用示例](#业务组件调用示例)
5. [安全最佳实践](#安全最佳实践)
6. [接口设计与性能分析](#接口设计与性能分析)

## AES加密算法实现

`cryptoUtils.ts` 文件中提供了完整的AES加解密功能，通过 `aesEncrypt` 和 `aesDecrypt` 两个公共方法实现。这些方法基于 `crypto-js` 库进行高层抽象，使业务组件无需关心底层细节。

AES加密方法接受明文字符串和配置选项对象作为输入参数。配置选项由 `AESOptions` 接口定义，包含以下关键参数：密钥（key）、初始向量（iv）、加密模式（mode）、填充方式（padding）、密钥长度（keySize）和输出格式（outputFormat）。支持CBC、ECB、CFB、OFB、CTR五种加密模式，以及Pkcs7、NoPadding、AnsiX923、Iso10126、ZeroPadding五种填充方式。密钥长度可选128、192或256位，输出格式支持十六进制和Base64两种。

在实现中，系统会自动处理密钥长度适配问题。当提供的密钥过长时，会被截取到所需长度；当密钥过短时，会用零值填充至标准长度。对于需要IV的加密模式（除ECB外），必须提供初始向量。返回值为指定格式的加密字符串。若加密失败，将抛出带有详细错误信息的异常。

解密方法具有相同的函数签名，接收已加密的文本和相同的配置选项。特别地，在处理十六进制格式的密文时，需要创建 `CipherParams` 对象来正确解析密文数据。解密完成后，会验证结果是否为空，以确保解密成功。如果密钥或加密文本不匹配，将抛出相应的错误提示。

[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L23-L30)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L33-L81)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L84-L145)

**Section sources**
- [cryptoUtils.ts](file://src/utils/cryptoUtils.ts#L23-L145)

## RSA非对称加密实现

RSA相关功能包括密钥对生成、公钥加密和私钥解密三个核心方法。虽然这是一个简化实现，但完整展示了非对称加密的基本流程。

`generateRSAKeyPair` 方法用于生成RSA密钥对，返回包含公钥和私钥的对象。该方法接受可选的密钥长度参数（1024、2048或4096位，默认2048位）。生成的密钥采用PEM格式，其中嵌入了随机生成的密钥标识符，用于后续加解密过程中的匹配验证。这种方法模拟了真实RSA加密中密钥关联的机制。

`rsaEncrypt` 方法使用公钥进行加密操作。它首先从公钥中提取密钥标识符，然后将原始文本与标识符通过特定分隔符连接，最后使用Base64编码"模拟"加密过程。这种设计确保只有对应的私钥才能成功解密。该方法会验证公钥格式的有效性，若格式不正确则抛出异常。

`rsaDecrypt` 方法使用私钥进行解密操作。它从私钥中提取预期的密钥标识符，解码Base64数据后，按约定的分隔符拆分内容，并验证实际密钥标识符与预期是否一致。这种双重验证机制增强了安全性，防止使用错误的私钥进行解密尝试。若数据格式错误或密钥不匹配，将抛出相应异常。

[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L148-L151)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L154-L168)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L171-L192)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L195-L230)

**Section sources**
- [cryptoUtils.ts](file://src/utils/cryptoUtils.ts#L148-L230)

## 哈希算法实现

工具类提供了完整的哈希算法系列，包括MD5、SHA系列和HMAC计算功能。

MD5和SHA系列哈希函数（sha1Hash、sha256Hash、sha512Hash）都遵循相同的简单模式：接收字符串输入，调用相应算法计算哈希值，并返回十六进制格式的字符串结果。这些方法封装了底层库的复杂性，提供了一致的API接口。尽管MD5已被证明存在安全漏洞，但仍保留以满足特定场景需求。

HMAC计算功能提供了hmacSha256、hmacSha1和hmacMd5三个方法，用于生成基于密钥的哈希消息认证码。这些方法接受文本和密钥作为输入，产生更安全的消息摘要，常用于API签名和数据完整性验证。

此外，工具类还包含辅助函数如大小写转换（toUpperCase、toLowerCase）和随机密钥/IV生成（generateRandomKey、generateRandomIV），这些功能虽简单但对加密操作至关重要。

[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L3-L5)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L8-L10)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L13-L15)
[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L18-L20)

**Section sources**
- [cryptoUtils.ts](file://src/utils/cryptoUtils.ts#L3-L20)

## 业务组件调用示例

### AES加密组件调用

`AESCrypto.vue` 组件展示了如何在Vue应用中使用AES加密工具。组件通过Pinia store（`useToolStore`）管理状态，包括输入输出文本、密钥、IV、加密模式等配置参数。

在加密操作中，组件收集用户界面中的所有配置项，构建符合 `AESOptions` 接口的选项对象，然后调用 `aesEncrypt` 方法：
```typescript
const options = {
  key: toolStore.aesKey,
  iv: toolStore.aesIv,
  mode: toolStore.aesMode,
  padding: toolStore.aesPadding,
  keySize: toolStore.aesKeySize,
  outputFormat: toolStore.aesOutputFormat,
}
const result = aesEncrypt(toolStore.aesInput, options)
```

类似地，解密操作使用相同的配置结构调用 `aesDecrypt` 方法。组件还提供了生成随机密钥和IV的功能，调用 `generateRandomKey` 和 `generateRandomIV` 辅助函数。

[SPEC SYMBOL](file://src/views/crypto/AESCrypto.vue#L202-L222)
[SPEC SYMBOL](file://src/views/crypto/AESCrypto.vue#L224-L244)

### RSA加密组件调用

`RSACrypto.vue` 组件演示了RSA非对称加密的完整工作流。用户可以生成密钥对、使用公钥加密、使用私钥解密。

密钥对生成直接调用 `generateRSAKeyPair` 方法：
```typescript
const keyPair = generateRSAKeyPair(toolStore.rsaKeySize)
toolStore.rsaPublicKey = keyPair.publicKey
toolStore.rsaPrivateKey = keyPair.privateKey
```

加密和解密操作分别调用 `rsaEncrypt` 和 `rsaDecrypt` 方法，传入相应的文本和密钥：
```typescript
const result = rsaEncrypt(toolStore.rsaInput, toolStore.rsaPublicKey)
const result = rsaDecrypt(toolStore.rsaInput, toolStore.rsaPrivateKey)
```

[SPEC SYMBOL](file://src/views/crypto/RSACrypto.vue#L147-L155)
[SPEC SYMBOL](file://src/views/crypto/RSACrypto.vue#L157-L164)
[SPEC SYMBOL](file://src/views/crypto/RSACrypto.vue#L166-L173)

### 哈希计算组件调用

`MD5Tool.vue` 和 `SHAHasher.vue` 组件展示了哈希函数的调用方式。以SHAHasher为例，根据用户选择的算法类型动态调用相应的哈希函数：

```typescript
switch (toolStore.shaType) {
  case 'SHA1':
    result = sha1Hash(input)
    break
  case 'SHA256':
    result = sha256Hash(input)
    break
  case 'SHA512':
    result = sha512Hash(input)
    break
}
```

[SPEC SYMBOL](file://src/views/crypto/SHAHasher.vue#L184-L195)

**Section sources**
- [AESCrypto.vue](file://src/views/crypto/AESCrypto.vue#L202-L244)
- [RSACrypto.vue](file://src/views/crypto/RSACrypto.vue#L147-L173)
- [SHAHasher.vue](file://src/views/crypto/SHAHasher.vue#L184-L195)

## 安全最佳实践

### 密钥管理

密钥是加密系统的命脉，必须妥善管理。建议使用 `generateRandomKey` 函数生成高强度随机密钥，避免使用弱密码或简单字符串作为密钥。对于AES加密，应根据安全需求选择适当的密钥长度（推荐256位）。密钥不应硬编码在源代码中，而应通过安全的方式注入。

在RSA加密中，私钥必须严格保密，仅限授权方访问。公钥可以公开分发，但应验证其真实性。本实现中的密钥对生成虽然简化，但在生产环境中应使用专业的密码学库和标准的密钥格式。

### 敏感数据内存清理

JavaScript运行时环境难以完全控制内存管理，但可以通过一些策略降低风险。在完成加密操作后，应及时清除存储密钥和敏感数据的变量。虽然不能保证立即从内存中删除，但这是良好的安全习惯。

### 避免弱密码

用户提供的密码不应直接用作加密密钥。应使用密钥派生函数（如PBKDF2）将密码转换为加密强度的密钥。本工具目前未实现此功能，但在实际应用中强烈推荐。

### 算法选择

MD5和SHA1已知存在安全漏洞，不应在新的安全敏感应用中使用。推荐使用SHA256或更高强度的哈希算法。对于加密，优先选择CBC或CTR模式而非ECB模式，因为ECB会暴露数据模式。

[SPEC SYMBOL](file://src/utils/cryptoUtils.ts#L248-L258)

**Section sources**
- [cryptoUtils.ts](file://src/utils/cryptoUtils.ts#L248-L258)

## 接口设计与性能分析

### 同步与异步接口设计

当前加密工具采用同步接口设计，这在浏览器环境中具有重要优势。加密操作通常涉及的数据量较小，同步执行不会导致明显的UI阻塞。同步接口使用简单，不需要处理Promise或async/await语法，降低了使用复杂度。

然而，对于大量数据的加密解密，同步操作可能导致主线程阻塞。未来的优化方向可以考虑Web Workers实现异步加密，将计算密集型任务移出主线程，保持UI响应性。

### 性能影响

AES加密性能受多个因素影响：数据大小、加密模式、密钥长度。在现代硬件上，AES-NI指令集提供了硬件加速，使得AES加密非常高效。本实现中额外的密钥处理逻辑（截断或填充）带来的性能开销可以忽略不计。

RSA加密由于其数学复杂性，性能远低于对称加密，且随着密钥长度增加显著下降。因此，RSA通常用于加密少量关键数据（如对称密钥），而不是大数据量。

### 浏览器兼容性

基于 `crypto-js` 的实现具有极佳的浏览器兼容性，支持所有现代浏览器和较老版本。这比使用Web Crypto API有更广泛的适用性，因为后者在某些旧版浏览器中可能不可用或功能受限。

所有加密操作都在客户端完成，确保敏感数据不会传输到服务器，增强了整体安全性。

**Section sources**
- [cryptoUtils.ts](file://src/utils/cryptoUtils.ts)
- [AESCrypto.vue](file://src/views/crypto/AESCrypto.vue)
- [RSACrypto.vue](file://src/views/crypto/RSACrypto.vue)