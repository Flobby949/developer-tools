# 状态管理设计

<cite>
**本文档引用的文件**
- [app.ts](file://src/stores/app.ts)
- [tool.ts](file://src/stores/tool.ts)
- [AiChat.vue](file://src/views/ai/AiChat.vue)
</cite>

## 目录
1. [全局应用状态管理](#全局应用状态管理)
2. [工具模块状态管理](#工具模块状态管理)
3. [状态共享机制](#状态共享机制)
4. [Actions与Getters实现](#actions与getters实现)
5. [状态变更追踪与调试](#状态变更追踪与调试)

## 全局应用状态管理

`app.ts` 文件定义了 `useAppStore`，用于管理整个应用程序的全局状态。该状态包括当前选中的工具、用户主题偏好以及工具分类列表等核心信息。

全局状态通过 Pinia 的 `defineStore` 方法创建，使用 `ref` 和 `reactive` 来声明响应式数据。其中，`currentTool` 用于跟踪当前活跃的工具标识，`themePreference` 存储用户的主题选择（'auto' | 'light' | 'dark'），而 `theme` 则根据用户偏好和系统设置计算出实际的主题值。

为了实现状态持久化，应用在初始化时从 `localStorage` 中读取用户主题偏好，并在用户更改偏好时自动保存。具体来说，`THEME_PREFERENCE_KEY` 键用于存储用户的选择，确保刷新页面后仍能保持一致的用户体验。同时，当实际主题发生变化时，会触发 `saveTheme` 函数将当前主题写入 `localStorage`，并通过 `updateThemeColor` 更新页面的 `<meta name="theme-color">` 标签，以适配不同设备的显示需求。

此外，通过 `watch` 监听器监控 `themePreference` 和 `theme` 的变化，实现了对主题偏好的实时同步和持久化存储。这不仅保证了状态的一致性，还提升了应用的整体性能和用户体验。

**Section sources**
- [app.ts](file://src/stores/app.ts#L0-L306)

## 工具模块状态管理

`tool.ts` 文件中定义的 `useToolStore` 负责管理各个工具模块的特定状态，如 AI 对话助手的输入文本、加密选项及历史记录等。这种模块化的设计使得每个工具的状态相互隔离，避免了状态污染和命名冲突的问题。

例如，在 AI 对话模块中，`aiChatMessages` 存储了聊天消息的历史记录，`aiChatInput` 记录了用户当前输入的内容，`aiChatConfig` 包含了 API 配置信息，如基础 URL、API 密钥、模型名称等。这些状态变量均使用 `ref` 声明为响应式数据，确保视图能够及时更新。

对于其他工具，如 JSON 格式化、Base64 编码、AES 加密等，也分别定义了相应的状态变量来存储输入输出内容、配置参数等。所有工具的状态都被组织在一个单一的 store 中，便于统一管理和维护。

模块化设计的优势在于提高了代码的可维护性和扩展性。新增或修改某个工具的功能时，只需关注其对应的状态部分，而不影响其他模块。同时，由于各模块状态独立，可以轻松地进行单元测试和调试。

**Section sources**
- [tool.ts](file://src/stores/tool.ts#L0-L368)

## 状态共享机制

状态在组件间的共享主要通过导入并使用相应的 store 实例来实现。例如，在 `AiChat.vue` 组件中，通过 `import { useToolStore } from '@/stores/tool'` 引入 `useToolStore`，然后调用 `const toolStore = useToolStore()` 获取 store 实例，从而访问其中的状态和方法。

具体而言，`AiChat.vue` 组件利用 `toolStore.aiChatMessages` 显示聊天记录，绑定 `toolStore.aiChatInput` 到输入框以获取用户输入，并通过 `toolStore.aiChatConfig` 读取 API 配置。当用户发送消息时，组件会将新消息添加到 `toolStore.aiChatMessages` 数组中，并清空 `toolStore.aiChatInput`。

同样，全局应用状态也可以被多个组件共享。比如，`AppLayout.vue` 组件通过 `useAppStore` 获取 `appStore` 实例，进而读取 `appStore.theme` 来动态调整界面风格。这样，无论用户切换到哪个工具页面，都能看到一致的主题效果。

这种基于 Pinia 的状态管理模式简化了跨组件通信的过程，减少了 prop 传递的复杂度，使代码更加简洁高效。

**Section sources**
- [AiChat.vue](file://src/views/ai/AiChat.vue#L0-L799)

## Actions与Getters实现

在 `app.ts` 和 `tool.ts` 中，除了定义状态外，还提供了丰富的 actions 和 getters 来操作和计算状态。

Actions 是用来改变状态的方法。例如，`setCurrentTool(tool: string)` 用于更新当前选中的工具；`setThemePreference(preference: 'auto' | 'light' | 'dark')` 设置新的主题偏好，并相应地更新实际主题；`toggleTheme()` 实现了在 'auto'、'light'、'dark' 之间循环切换主题的功能。这些 actions 可以直接在组件中调用，实现对状态的安全修改。

Getters 则是用于派生状态的函数。它们不会改变原始状态，而是基于现有状态返回新的计算结果。例如，`getThemeDisplayName()` 返回当前主题偏好的中文描述（如“跟随系统”、“浅色模式”、“深色模式”）；`getThemeIcon()` 根据主题偏好返回对应的图标符号（如地球、太阳、月亮）。这些 getters 在模板中可以直接使用，提供更友好的用户界面。

通过合理运用 actions 和 getters，不仅可以增强状态管理的灵活性，还能提高代码的复用率和可读性。

**Section sources**
- [app.ts](file://src/stores/app.ts#L210-L252)
- [tool.ts](file://src/stores/tool.ts#L350-L367)

## 状态变更追踪与调试

Pinia 提供了强大的状态变更追踪能力，结合 Vue Devtools 可以方便地监控状态流的变化。开发者可以在浏览器中打开 Vue Devtools 插件，查看各个 store 的状态树，观察每次 action 触发后的状态变化过程。

特别是在开发阶段，启用 Vue Devtools 后，可以通过时间轴功能回溯历史状态，快速定位问题所在。这对于排查复杂的逻辑错误非常有帮助。此外，Devtools 还支持断点调试，允许暂停在特定的状态变更上，检查当时的上下文环境。

为了进一步提升调试效率，建议在关键的 action 和 getter 上添加详细的注释说明，明确指出其作用和预期行为。同时，利用 TypeScript 的类型系统，为状态和方法定义精确的接口，减少运行时错误的发生概率。

总之，借助 Pinia 和 Vue Devtools 的组合，可以构建一个高度透明且易于维护的状态管理体系，显著改善开发体验。

**Section sources**
- [app.ts](file://src/stores/app.ts#L250-L305)
- [tool.ts](file://src/stores/tool.ts#L350-L367)